"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const sign_1 = __importDefault(require("../../base/sign"));
const protobufjs_1 = __importDefault(require("protobufjs"));
const lz4_1 = __importDefault(require("./lz4"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("./utils");
const TIMEOUT = 100000;
const defaultOptions = (0, utils_1.getDefaultOption)();
class Service {
    constructor(options) {
        this.setRegion = (region) => {
            this.options.region = region;
        };
        this.setHost = (host) => (this.options.host = host);
        this.setVersion = (version) => (this.options.version = version);
        this.setProtocol = (protocol) => (this.options.protocol = protocol);
        this.setAccessKeyId = (accessKeyId) => (this.options.accessKeyId = accessKeyId);
        this.setSecretKey = (secretKey) => (this.options.secretKey = secretKey);
        this.setSessionToken = (sessionToken) => (this.options.sessionToken = sessionToken);
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
    }
    static async fetch(uri, requestObj) {
        const res = await (0, axios_1.default)(Object.assign({ url: uri, timeout: TIMEOUT }, requestObj));
        return res === null || res === void 0 ? void 0 : res.data;
    }
    /**
     * transfer json to protobuf buffer
     */
    static async objToProtoBuffer(obj) {
        const root = await protobufjs_1.default.load(path_1.default.join(__dirname, "./tls.proto"));
        const type = root.lookupType("pb.LogGroupList");
        const errMsg = type.verify(obj);
        if (errMsg)
            throw new Error(errMsg);
        const message = type.create(obj);
        return type.encode(message).finish();
    }
    // protobuf buffer compress
    static LZ4Compress(input) {
        let output = Buffer.alloc(lz4_1.default.encodeBound(input.length));
        const compressedSize = lz4_1.default.encodeBlock(input, output);
        if (!compressedSize) {
            throw new Error("no need to compress");
        }
        output = output.slice(0, compressedSize);
        return output;
    }
    createAPI(Path, createParams) {
        const { method = "GET", version: versionFromParam } = createParams || {};
        return async (requestData, config) => {
            const { accessKeyId, secretKey, sessionToken, host, protocol, version: versionFromOptions, serviceName, region, } = this.options;
            const version = versionFromParam || versionFromOptions;
            if (!accessKeyId || !secretKey || !host)
                throw new Error(`[tls-node-sdk] host and accessKeyId and secretKey is necessary`);
            const requestObj = Object.assign(Object.assign({ region,
                method, pathname: `/${Path}` }, config), { headers: Object.assign(Object.assign({}, config === null || config === void 0 ? void 0 : config.headers), { "x-tls-apiversion": version }) });
            if (method === "GET") {
                requestObj.params = requestData;
            }
            else {
                requestObj.headers["content-type"] = "application/json";
                requestObj.body = requestData;
                requestObj.data = requestData;
            }
            const signer = new sign_1.default(requestObj, serviceName);
            signer.addAuthorization({ accessKeyId, secretKey, sessionToken });
            return Service.fetch(`${protocol}//${host}/${Path}`.trim(), requestObj);
        };
    }
    createPutLogsAPI(Path) {
        return async (requestData, config) => {
            const { LogGroupList, CompressType, TopicId, HashKey } = requestData;
            if (!LogGroupList)
                throw new Error(`LogGroupList is necessary`);
            // transfer json to compressed protobuf buffer
            const pbMessage = LogGroupList;
            let lz4CompressFailed = false;
            let output = pbMessage;
            if (CompressType === "lz4") {
                try {
                    output = Service.LZ4Compress(pbMessage);
                }
                catch (err) {
                    lz4CompressFailed = true;
                }
            }
            const { accessKeyId, secretKey, sessionToken, host, version, protocol, serviceName, region } = this.options;
            if (!accessKeyId || !secretKey || !host || !region) {
                const missingParams = [];
                if (!accessKeyId)
                    missingParams.push("accessKeyId");
                if (!secretKey)
                    missingParams.push("secretKey");
                if (!host)
                    missingParams.push("host");
                if (!region)
                    missingParams.push("region");
                throw new Error(`[tls-node-sdk] ${missingParams.join(" and ")} is necessary`);
            }
            const requestObj = Object.assign(Object.assign({ region, method: "POST", pathname: `/${Path}` }, config), { headers: Object.assign(Object.assign({}, config === null || config === void 0 ? void 0 : config.headers), { "x-tls-apiversion": version, "content-type": "application/x-protobuf", "x-tls-compresstype": !lz4CompressFailed ? CompressType : "", "x-tls-hashkey": HashKey || "", "x-tls-bodyrawsize": pbMessage.length }) });
            if (!requestObj.headers["x-tls-compresstype"]) {
                delete requestObj.headers["x-tls-compresstype"];
            }
            requestObj.body = output;
            requestObj.data = output;
            requestObj.params = {
                TopicId,
            };
            const signer = new sign_1.default(requestObj, serviceName);
            signer.addAuthorization({ accessKeyId, secretKey, sessionToken });
            return Service.fetch(`${protocol}//${host}/${Path}`.trim(), requestObj);
        };
    }
}
exports.default = Service;
//# sourceMappingURL=service.js.map