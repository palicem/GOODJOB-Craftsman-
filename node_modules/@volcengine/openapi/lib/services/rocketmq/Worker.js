"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Worker = void 0;
const agent_1 = require("./utils/agent");
const logger_1 = __importDefault(require("./utils/logger"));
const error_1 = require("./utils/error");
const common_1 = require("./utils/common");
const connectableStatus = ["initialized", "closed", "connectFailed"];
const closeableStatus = ["connected", "closeFailed"];
class Worker {
    constructor(client, options) {
        this._clientToken = undefined;
        this._heartBeatTimer = null;
        /**
         * 保存链接时的选项，用于重连
         */
        this._connectOption = null;
        const { type } = options;
        this._client = client;
        this._workerType = type;
        this._workerAgent = new agent_1.MQAgent({ maxSockets: 1, keepAlive: true });
        this._logger = new logger_1.default({ namespace: this._workerType });
        this._workerStatus = "initialized";
    }
    _startHeartBeat() {
        this._stopHeartBeat();
        const interval = (this._client.SESSION_TIMEOUT * 1000) / 2;
        this._heartBeatTimer = setInterval(() => this._heartBeat(), interval);
    }
    _stopHeartBeat() {
        if (this._heartBeatTimer) {
            clearInterval(this._heartBeatTimer);
            this._heartBeatTimer = null;
        }
    }
    async _connect(options) {
        if (!connectableStatus.includes(this._workerStatus)) {
            throw new error_1.MQError(`[RocketMQ-node-sdk] Can not connect when ${this._workerType}'s status is ${this._workerStatus}`);
        }
        // 保存option 以便重连时使用
        this._connectOption = options;
        try {
            this._workerStatus = "connecting";
            const res = await this._connectRequest(options);
            this._clientToken = res.result.clientToken;
            this._startHeartBeat();
            this._workerStatus = "connected";
            this._logger.info("Connect succeed.", {
                payload: Object.assign({ clientToken: this._clientToken }, options),
            });
        }
        catch (error) {
            this._workerStatus = "connectFailed";
            const msg = `Connect failed: ${error.message}`;
            this._logger.error(msg, {
                payload: (0, error_1.isMQError)(error) ? error.cause : undefined,
            });
            throw new error_1.MQError(`[RocketMQ-node-sdk] ${msg}`);
        }
    }
    async _close() {
        if (!closeableStatus.includes(this._workerStatus)) {
            throw new error_1.MQError(`[RocketMQ-node-sdk] Can not close when ${this._workerType}'s status is ${this._workerStatus}`);
        }
        try {
            this._workerStatus = "closing";
            await this._closeRequest();
            this._clientToken = undefined;
            this._connectOption = null;
            this._stopHeartBeat();
            this._workerStatus = "closed";
            this._logger.info("Close succeed.", {
                payload: { clientToken: this._clientToken },
            });
        }
        catch (error) {
            this._workerStatus = "closeFailed";
            const msg = `Close failed: ${error.message}`;
            this._logger.error(msg, {
                payload: (0, error_1.isMQError)(error) ? error.cause : undefined,
            });
            throw new error_1.MQError(`[RocketMQ-node-sdk] ${msg}`);
        }
    }
    async _reconnect() {
        var _a;
        // 如果有_reconnectResolver，说明正在重连，不需要执行后续重连逻辑
        if (this._reconnectResolver)
            return;
        this._reconnectResolver = new common_1.Resolver();
        // 开始不断尝试重连
        // 仅仅在 connected状态才不断尝试重连，防止关闭后循环依然在执行
        while (this._workerStatus === "connected") {
            try {
                this._logger.info("Reconnecting.", {
                    payload: { prevClientToken: this._clientToken },
                });
                const res = await this._connectRequest(this._connectOption);
                this._clientToken = res.result.clientToken;
                this._logger.info("Reconnect succeed.", {
                    payload: { clientToken: this._clientToken },
                });
                break;
            }
            catch (error) {
                this._logger.error(`Reconnect Failed: ${error.message}`, {
                    payload: (0, error_1.isMQError)(error) ? error.cause : undefined,
                });
            }
            await (0, common_1.sleep)(10000); // 10秒重试一次
        }
        // 重连后要解决
        (_a = this._reconnectResolver) === null || _a === void 0 ? void 0 : _a.resolve();
        this._reconnectResolver = null;
    }
    _waitReconnectIfNecessary() {
        if (this._reconnectResolver) {
            return this._reconnectResolver.promise;
        }
        return Promise.resolve();
    }
    async _heartBeat() {
        try {
            await this._heartBeatRequest();
            this._logger.debug("Heart beat succeed.", {
                payload: { clientToken: this._clientToken },
            });
        }
        catch (error) {
            this._logger.error(`Heart beat failed: ${error.message}`, {
                payload: (0, error_1.isMQError)(error) ? error.cause : undefined,
            });
        }
    }
    _connectRequest(options) {
        const { subscriptions, group, properties } = options;
        return this._client._request({
            method: "POST",
            path: "/v1/clients",
            data: {
                type: this._workerType,
                clientVersion: this._client.VERSION,
                clientToken: this._clientToken,
                subscriptions,
                group,
                properties: Object.assign(Object.assign({}, properties), { session_timeout: String(this._client.SESSION_TIMEOUT) }),
            },
            httpAgent: this._workerAgent,
        });
    }
    _closeRequest() {
        return this._client._request({
            method: "DELETE",
            path: `/v1/clients/${this._clientToken}`,
            data: {
                clientToken: this._clientToken,
                properties: {},
            },
            httpAgent: this._workerAgent,
        });
    }
    _heartBeatRequest() {
        if (!this._clientToken) {
            return;
        }
        return this._client._request({
            method: "POST",
            path: "/v1/heartbeats",
            data: { clientToken: this._clientToken },
            httpAgent: this._workerAgent,
        });
    }
}
exports.Worker = Worker;
//# sourceMappingURL=Worker.js.map