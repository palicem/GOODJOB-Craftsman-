"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultService = exports.VodService = void 0;
const service_1 = __importDefault(require("../../base/service"));
const utils_1 = require("../../base/utils");
const sign_1 = __importStar(require("../../base/sign"));
const util_1 = require("util");
const crc_1 = require("crc");
const fs_1 = __importStar(require("fs"));
const lodash_get_1 = __importDefault(require("lodash.get"));
const axios_1 = __importDefault(require("axios"));
const constants_1 = require("./constants");
const p_limit_1 = __importDefault(require("p-limit"));
const stream_1 = require("stream");
// 进程级chunk上传并发数限制
const maxLimit = (0, p_limit_1.default)(20);
const fsStat = fs_1.promises ? fs_1.promises.stat : (0, util_1.promisify)(fs_1.default.stat);
const fsOpen = (0, util_1.promisify)(fs_1.default.open);
const fsRead = (0, util_1.promisify)(fs_1.default.read);
const fsClose = (0, util_1.promisify)(fs_1.default.close);
// 获取文件流的大小
const _getStreamSize = async (stream) => {
    if (!(stream instanceof stream_1.Readable)) {
        return null;
    }
    // 仅当是可统计的文件流时获取大小
    if (typeof stream.path === "string" && stream instanceof stream_1.Readable) {
        try {
            // 仅当是可统计的文件流时获取大小
            return (await fsStat(stream.path)).size;
        }
        catch (_a) { }
    }
    // 对不可统计的流返回null
    return null;
};
// 考虑到filename可能包含中文 因此url encode下 否则分片上传会失败
function getEncodedUri(originUri) {
    if (!originUri)
        return "";
    const arr = originUri.split("/");
    return arr.map((v) => encodeURIComponent(v)).join("/");
}
class VodService extends service_1.default {
    constructor(options) {
        super(Object.assign({ defaultVersion: "2020-08-01", host: "vod.volcengineapi.com", serviceName: "vod" }, options));
        this.uploadToBStream = async (params) => {
            /* 校验文件是否合法 */
            const { SpaceName, FileType, FileName, FileExtension, maxConcurrency, FileSize, // 流大小
            Content, // 流内容
             } = params;
            if (!FileType || !constants_1.VALID_TYPE_LIST.includes(FileType)) {
                throw new Error("invalid file type");
            }
            if (!(Content instanceof stream_1.Readable)) {
                throw new Error("invalid stream content, please use stream content or plasease use file path to upload");
            }
            /* 获取文件上传凭证及地址 */
            const applyReq = {
                SpaceName,
                FileType: FileType || "media",
                FileName,
                FileExtension,
            };
            const applyRes = await this.ApplyUploadInfo(applyReq);
            if (applyRes.ResponseMetadata.Error) {
                throw new Error(JSON.stringify(applyRes));
            }
            const uploadAddress = (0, lodash_get_1.default)(applyRes, "Result.Data.UploadAddress");
            const oid = (0, lodash_get_1.default)(uploadAddress, "StoreInfos[0].StoreUri", "");
            const auth = (0, lodash_get_1.default)(uploadAddress, "StoreInfos[0].Auth", "");
            const sessionKey = (0, lodash_get_1.default)(uploadAddress, "SessionKey", "");
            const host = (0, lodash_get_1.default)(uploadAddress, "UploadHosts[0]", "");
            const streamSize = await _getStreamSize(Content);
            const size = FileSize !== null && FileSize !== void 0 ? FileSize : streamSize;
            if (!size) {
                throw new Error("invalid FileSize");
            }
            /* 获取文件上传凭证及地址 */
            /* 判断文件大小,选择上传方式 */
            if (size <= constants_1.MinChunkSize) {
                await this._dynamicUploadWithUnknownSize(Content, host, oid, auth);
            }
            else {
                await this.chunkedStreamUpload(Content, host, oid, auth, true, maxConcurrency);
            }
            // const cost = dayjs().diff(startTime, "second");
            // const avgSpeed = fileSize / cost;
            return { /*oid,*/ sessionKey /* avgSpeed*/ };
        };
        this._dynamicUploadWithUnknownSize = async (stream, host, oid, auth) => {
            var _a, e_1, _b, _c;
            let buffer = Buffer.alloc(0);
            try {
                try {
                    for (var _d = true, stream_2 = __asyncValues(stream), stream_2_1; stream_2_1 = await stream_2.next(), _a = stream_2_1.done, !_a;) {
                        _c = stream_2_1.value;
                        _d = false;
                        try {
                            const chunk = _c;
                            buffer = Buffer.concat([buffer, chunk]);
                        }
                        finally {
                            _d = true;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = stream_2.return)) await _b.call(stream_2);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                // 未超过阈值执行直传
                return this.directUploadStream(buffer, host, oid, auth);
            }
            finally {
                stream.destroy();
            }
        };
        this.chunkedStreamUpload = async (stream, host, oid, auth, isLargeFile, maxConcurrency = 4) => {
            var _a, e_2, _b, _c;
            const limit = (0, p_limit_1.default)(maxConcurrency);
            let buffer = Buffer.alloc(0);
            let partNumber = 0;
            const parts = [];
            try {
                const uploadId = await this.initUploadPart(host, oid, auth, isLargeFile);
                try {
                    // 流数据处理循环
                    for (var _d = true, stream_3 = __asyncValues(stream), stream_3_1; stream_3_1 = await stream_3.next(), _a = stream_3_1.done, !_a;) {
                        _c = stream_3_1.value;
                        _d = false;
                        try {
                            const chunk = _c;
                            buffer = Buffer.concat([buffer, chunk]);
                            // 动态切割分片
                            while (buffer.length >= constants_1.MinChunkSize) {
                                const chunkBuffer = buffer.subarray(0, constants_1.MinChunkSize);
                                buffer = buffer.subarray(constants_1.MinChunkSize);
                                partNumber++;
                                // 提交分片上传任务
                                parts.push(await limit(async () => {
                                    return maxLimit(async () => {
                                        const check_sum = await this.uploadPart(host, oid, auth, uploadId, partNumber, chunkBuffer, isLargeFile);
                                        return check_sum;
                                    });
                                }));
                            }
                        }
                        finally {
                            _d = true;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = stream_3.return)) await _b.call(stream_3);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                // 上传最后的分片
                if (buffer.length > 0) {
                    partNumber++;
                    parts.push(await this.uploadPart(host, oid, auth, uploadId, partNumber, buffer, isLargeFile));
                }
                await this.uploadMergePart(host, oid, auth, uploadId, parts, isLargeFile);
            }
            finally {
                stream.destroy();
            }
        };
        // 直接上传
        this.directUploadStream = async (buffer, host, oid, auth) => {
            await (0, axios_1.default)(`https://${host}/${getEncodedUri(oid)}`, {
                method: "put",
                headers: {
                    "Content-CRC32": (0, crc_1.crc32)(buffer).toString(16).padStart(8, "0"),
                    Authorization: auth,
                },
                data: buffer,
                maxBodyLength: constants_1.MinChunkSize * 2,
            });
        };
        this.uploadToB = async (params) => {
            /* 校验文件是否合法 */
            const { SpaceName, FilePath, FileType, FileName, FileExtension, maxConcurrency, Content, // 流内容
             } = params;
            if (Content instanceof stream_1.Readable) {
                return this.uploadToBStream(params);
            }
            const fileStat = await fsStat(FilePath);
            const fileSize = fileStat.size;
            if (!fileStat.isFile()) {
                throw new Error("no such file on file path");
            }
            if (!FileType || !constants_1.VALID_TYPE_LIST.includes(FileType)) {
                throw new Error("invalid file type");
            }
            /* 获取文件上传凭证及地址 */
            const applyReq = {
                SpaceName,
                FileType: FileType || "media",
                FileName,
                FileExtension,
            };
            const applyRes = await this.ApplyUploadInfo(applyReq);
            if (applyRes.ResponseMetadata.Error) {
                throw new Error(JSON.stringify(applyRes));
            }
            const uploadAddress = (0, lodash_get_1.default)(applyRes, "Result.Data.UploadAddress");
            const oid = (0, lodash_get_1.default)(uploadAddress, "StoreInfos[0].StoreUri", "");
            const auth = (0, lodash_get_1.default)(uploadAddress, "StoreInfos[0].Auth", "");
            const sessionKey = (0, lodash_get_1.default)(uploadAddress, "SessionKey", "");
            const host = (0, lodash_get_1.default)(uploadAddress, "UploadHosts[0]", "");
            // const startTime = dayjs();
            /* 判断文件大小,选择上传方式 */
            if (fileSize <= constants_1.MinChunkSize) {
                await this.directUpload(FilePath, host, oid, auth, fileSize);
            }
            else {
                await this.chunkUpload(FilePath, host, oid, auth, fileSize, true, maxConcurrency);
            }
            // const cost = dayjs().diff(startTime, "second");
            // const avgSpeed = fileSize / cost;
            return { /*oid,*/ sessionKey /* avgSpeed*/ };
        };
        // 直接上传
        this.directUpload = async (filePath, host, oid, auth, size) => {
            let fd = 0;
            try {
                const bufferInit = Buffer.alloc(size);
                fd = await fsOpen(filePath, "r");
                const { buffer } = await fsRead(fd, bufferInit, 0, size, 0);
                await (0, axios_1.default)(`https://${host}/${getEncodedUri(oid)}`, {
                    method: "put",
                    headers: {
                        "Content-CRC32": (0, crc_1.crc32)(buffer).toString(16).padStart(8, "0"),
                        Authorization: auth,
                    },
                    data: buffer,
                    maxBodyLength: constants_1.MinChunkSize * 2,
                });
            }
            finally {
                await fsClose(fd);
            }
        };
        this.createUploadTask = (host, oid, auth, uploadId, isLargeFile, fd, chunkSize, position, partNum) => {
            // 被maxLimit包裹后，无论同时上传多少个文件，最多20个分片并发上传，避免占用内存过多
            return maxLimit(async () => {
                const bufferInit = Buffer.alloc(chunkSize);
                const { buffer } = await fsRead(fd, bufferInit, 0, chunkSize, position);
                const part = await this.uploadPart(host, oid, auth, uploadId, partNum, buffer, isLargeFile);
                return part;
            });
        };
        // 大文件分片上传
        this.chunkUpload = async (filePath, host, oid, auth, size, isLargeFile, maxConcurrency = 4) => {
            const limit = (0, p_limit_1.default)(maxConcurrency);
            let fd = 0;
            try {
                const uploadId = await this.initUploadPart(host, oid, auth, isLargeFile); // 获取上传id
                const n = Math.floor(size / constants_1.MinChunkSize); // 向下取整
                const lastSize = size % constants_1.MinChunkSize;
                const lastNum = n - 1;
                const parts = []; // 存储校验和列表
                fd = await fsOpen(filePath, "r");
                const tasks = [];
                for (let i = 0; i < lastNum; i++) {
                    let partNum = i;
                    if (isLargeFile) {
                        partNum = i + 1;
                    }
                    // 被limit包裹后，确保每个文件同时最多上传maxConcurrency个分片
                    tasks.push(limit(this.createUploadTask, host, oid, auth, uploadId, isLargeFile, fd, constants_1.MinChunkSize, i * constants_1.MinChunkSize, partNum).then((part) => {
                        parts[i] = part;
                    }));
                }
                tasks.push(limit(this.createUploadTask, host, oid, auth, uploadId, isLargeFile, fd, constants_1.MinChunkSize + lastSize, lastNum * constants_1.MinChunkSize, isLargeFile ? lastNum + 1 : lastNum).then((part) => {
                    parts[lastNum] = part;
                }));
                await Promise.all(tasks);
                await this.uploadMergePart(host, oid, auth, uploadId, parts, isLargeFile);
            }
            finally {
                await fsClose(fd);
            }
        };
        this.initUploadPart = async (host, oid, auth, isLargeFile) => {
            try {
                const url = `https://${host}/${getEncodedUri(oid)}?uploads`;
                const headers = { Authorization: auth };
                if (isLargeFile) {
                    headers["X-Storage-Mode"] = "gateway";
                }
                const res = await (0, axios_1.default)(url, {
                    method: "put",
                    headers,
                });
                const uploadID = (0, lodash_get_1.default)(res, "data.payload.uploadID", "");
                if (uploadID.length === 0) {
                    throw new Error("get empty uploadID");
                }
                return uploadID;
            }
            catch (err) {
                throw new Error("init upload error:" + err);
            }
        };
        this.uploadPart = async (host, oid, auth, uploadID, partNumber, data, isLargeFile) => {
            try {
                const url = `https://${host}/${getEncodedUri(oid)}?partNumber=${partNumber}&uploadID=${uploadID}`;
                const check_sum = (0, crc_1.crc32)(data).toString(16).padStart(8, "0");
                const headers = { "Content-CRC32": check_sum, Authorization: auth };
                if (isLargeFile) {
                    headers["X-Storage-Mode"] = "gateway";
                }
                await (0, axios_1.default)(url, {
                    method: "put",
                    headers,
                    data,
                    maxBodyLength: constants_1.MinChunkSize * 2,
                });
                return check_sum;
            }
            catch (err) {
                throw new Error("upload part error:" + err);
            }
        };
        this.uploadMergePart = async (host, oid, auth, uploadID, checkSumList, isLargeFile) => {
            try {
                const url = `https://${host}/${getEncodedUri(oid)}?uploadID=${uploadID}`;
                const data = this.generateMergeBody(checkSumList);
                const headers = { Authorization: auth };
                if (isLargeFile) {
                    headers["X-Storage-Mode"] = "gateway";
                }
                await (0, axios_1.default)(url, {
                    method: "put",
                    headers,
                    data,
                    maxBodyLength: constants_1.MinChunkSize * 3,
                });
            }
            catch (err) {
                throw new Error("upload merge part error:" + err);
            }
        };
        this.generateMergeBody = (checkSumList) => {
            if (checkSumList.length === 0) {
                throw new Error("crc32 list empty");
            }
            const s = [];
            for (let i = 0; i < checkSumList.length; i++) {
                s.push(`${i}:${checkSumList[i]}`);
            }
            return s.join(",");
        };
        /**
         * 媒资上传
         */
        // 媒资上传
        this.UploadMedia = async (req) => {
            try {
                const defaultMediaFunctions = [{ Name: "GetMeta" }];
                const { SpaceName, FilePath = "", Functions = JSON.stringify(defaultMediaFunctions), CallbackArgs = "", FileName = "", FileExtension = "", maxConcurrency = 4, FileSize, // 流大小
                Content, // 流内容
                 } = req;
                const { sessionKey } = await this.uploadToB({
                    SpaceName,
                    FilePath,
                    FileType: "media",
                    FileName,
                    FileExtension,
                    maxConcurrency,
                    FileSize,
                    Content, // 流内容
                });
                const commitQuery = {
                    SpaceName,
                    SessionKey: sessionKey,
                    Functions,
                    CallbackArgs,
                };
                const commitRes = await this.CommitUploadInfo(commitQuery);
                if (commitRes.ResponseMetadata.Error) {
                    throw new Error(JSON.stringify(commitRes));
                }
                return commitRes;
            }
            catch (err) {
                throw new Error("Upload Media Error: " + err);
            }
        };
        // 素材上传
        this.UploadMaterial = async (req) => {
            try {
                const { SpaceName, FilePath = "", Functions = "", CallbackArgs = "", FileType = "", FileName = "", FileExtension = "", maxConcurrency = 4, FileSize, // 流大小
                Content, // 流内容
                 } = req;
                const { sessionKey } = await this.uploadToB({
                    SpaceName,
                    FilePath,
                    FileType,
                    FileName,
                    FileExtension,
                    maxConcurrency,
                    FileSize,
                    Content, // 流内容
                });
                const commitQuery = {
                    SpaceName,
                    SessionKey: sessionKey,
                    Functions,
                    CallbackArgs,
                };
                const commitRes = await this.CommitUploadInfo(commitQuery);
                if (commitRes.ResponseMetadata.Error) {
                    throw new Error(JSON.stringify(commitRes));
                }
                return commitRes;
            }
            catch (err) {
                throw new Error("Upload Material Error: " + err);
            }
        };
        // 获取上传地址与凭证
        this.ApplyUploadInfo = this.createAPI("ApplyUploadInfo", { Version: "2022-01-01" });
        // 确认上传
        this.CommitUploadInfo = this.createAPI("CommitUploadInfo", { Version: "2022-01-01" });
        // URL批量拉取上传
        this.UploadMediaByUrl = (req) => {
            Object.keys(req).forEach((key) => {
                if (Array.isArray(req[key])) {
                    req[key] = JSON.stringify(req[key]);
                }
            });
            return this.createAPI("UploadMediaByUrl")(req);
        };
        // 查询URL批量上传任务状态
        this.QueryUploadTaskInfo = this.createAPI("QueryUploadTaskInfo");
        /**
         * 媒资管理
         */
        //  查询媒资信息
        this.GetMediaInfos = this.createAPI("GetMediaInfos");
        //  修改媒资信息
        this.UpdateMediaInfo = this.createAPI("UpdateMediaInfo");
        //  修改媒资发布状态
        this.UpdateMediaPublishStatus = this.createAPI("UpdateMediaPublishStatus");
        //  获取封面候选结果
        this.GetRecommendedPoster = this.createAPI("GetRecommendedPoster");
        //  批量删除完整媒资
        this.DeleteMedia = this.createAPI("DeleteMedia");
        //  删除媒体文件
        this.DeleteTranscodes = this.createAPI("DeleteTranscodes");
        //  获取音视频列表
        this.GetMediaList = this.createAPI("GetMediaList");
        //  获取字幕文件
        this.GetSubtitleInfoList = this.createAPI("GetSubtitleInfoList");
        //  修改字幕发布状态
        this.UpdateSubtitleStatus = this.createAPI("UpdateSubtitleStatus");
        // 修改字幕信息
        this.UpdateSubtitleInfo = this.createAPI("UpdateSubtitleInfo");
        /**
         * 媒资处理
         */
        // 触发工作流
        this.StartWorkflow = this.createAPI("StartWorkflow");
        /**
         * 媒资播放
         */
        // 获取播放信息
        this.GetPlayInfo = this.createAPI("GetPlayInfo");
        //  签发 PlayAuthToken
        // expireSeconds 单位是 s
        this.GetPlayAuthToken = (query, expireSeconds) => {
            if (!query.Vid)
                throw new Error("传入的 Vid 为空");
            if (expireSeconds) {
                query["X-Expires"] = expireSeconds;
            }
            const getPlayInfoToken = this._signUrl({
                method: "GET",
                params: Object.assign({ Action: "GetPlayInfo", Version: "2020-08-01" }, query),
            });
            const ret = { GetPlayInfoToken: getPlayInfoToken, TokenVersion: "V2" };
            const retStr = JSON.stringify(ret).replace("\\u0026", "&");
            return Buffer.from(retStr).toString("base64");
        };
        //  签发私有 DRM 加密 AuthToken
        this.GetPrivateDrmAuthToken = (query, expireSeconds) => {
            if (!query.Vid)
                throw new Error("传入的 Vid 为空");
            if (query.DrmType && ["appdevice", "webdevice"].includes(query.DrmType) && !query.UnionInfo) {
                throw new Error("invalid unionInfo");
            }
            if (expireSeconds) {
                query["X-Expires"] = expireSeconds;
            }
            return this._signUrl({
                method: "GET",
                params: Object.assign({ Action: "GetPrivateDrmPlayAuth", Version: "2020-08-01" }, query),
            });
        };
        this.GetPrivateDrmPlayAuth = this.createAPI("GetPrivateDrmPlayAuth");
        // 本地签发临时上传凭证
        this.GetUploadToken = (expire) => {
            const policy = {
                Statement: [
                    {
                        Effect: "Allow",
                        Action: ["Vod:ApplyUploadInfo", "Vod:CommitUploadInfo"],
                        Resource: [],
                    },
                ],
            };
            return this.signSts2(policy, expire !== null && expire !== void 0 ? expire : 60 * 60 * 1000);
        };
        this._signUrl = (options) => {
            const { region } = (0, utils_1.getDefaultOption)();
            const sessionToken = this.getSessionToken();
            const accessKeyId = this.getAccessKeyId();
            const secretKey = this.getSecretKey();
            if (!accessKeyId || !secretKey) {
                throw new Error("accessKeyId or secretKey is invalid");
            }
            const { params, method = "GET", serviceName = "Vod" } = options;
            // 使用临时的一个signer来转换utc时间，因为实际上使用signer需要传入params字段
            const date = new sign_1.default({ method: "", region: "" }, "Vod")
                .iso8601(new Date())
                .replace(/[:\-]|\.\d{3}/g, "");
            const credentialScope = [date.substr(0, 8), region, serviceName, "request"].join("/");
            const signedHeaders = "";
            const paramsMap = Object.assign({ "X-Date": date, "X-NotSignBody": "", "X-Credential": accessKeyId + "/" + credentialScope, "X-Algorithm": "HMAC-SHA256", "X-SignedHeaders": signedHeaders, "X-SignedQueries": "" }, params);
            const sortedQueryMap = Object.keys(paramsMap)
                .sort()
                .reduce((map, curKey) => {
                map[curKey] = paramsMap[curKey];
                return map;
            }, {});
            if (sessionToken) {
                paramsMap["X-Security-Token"] = sessionToken;
            }
            paramsMap["X-SignedQueries"] = Object.keys(sortedQueryMap).join(";");
            const signer = new sign_1.default({
                region,
                method,
                pathname: "/",
                params: paramsMap,
            }, "Vod");
            const signature = signer.signature({ accessKeyId, secretKey }, date);
            paramsMap["X-Signature"] = signature.toString();
            return (0, sign_1.queryParamsToString)(paramsMap);
        };
    }
}
exports.VodService = VodService;
exports.defaultService = new VodService();
//# sourceMappingURL=index.js.map