"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Producer = exports.MessageProperties = void 0;
const error_1 = require("./utils/error");
const common_1 = require("./utils/common");
const Worker_1 = require("./Worker");
class MessageProperties {
    constructor() {
        this.properties = {};
    }
    delayAfter(second) {
        this.properties["__DELAY_AFTER"] = String(second);
    }
    delayAt(timeStamp) {
        this.properties["__DELAY_AT"] = String(timeStamp);
    }
    putProperty(key, value) {
        this.properties[key] = value;
    }
}
exports.MessageProperties = MessageProperties;
class Producer extends Worker_1.Worker {
    constructor(client) {
        if (!client)
            throw new error_1.MQError("Please pass the client instance of producer");
        super(client, { type: "producer" });
        this._producerAgent = this._workerAgent;
    }
    connect() {
        return this._connect({ properties: {} });
    }
    close() {
        return this._close();
    }
    async publishMessage(options) {
        if (!options) {
            throw new error_1.MQError(`[RocketMQ-node-sdk] please pass the message option`);
        }
        if (!options.topic) {
            throw new error_1.MQError(`[RocketMQ-node-sdk] topic can not be empty`);
        }
        if (!options.body) {
            throw new error_1.MQError(`[RocketMQ-node-sdk] body can not be empty`);
        }
        if (this._workerStatus !== "connected") {
            throw new error_1.MQError(`[RocketMQ-node-sdk] Can not publish message when producer's status is ${this._workerStatus}`);
        }
        try {
            // 如果正在重连，这里会等待重连成功后promise resolve
            await this._waitReconnectIfNecessary();
            const startTime = Date.now();
            const res = await this._publishMessageRequest(options);
            this._logger.debug(`Publish message succeed.`, {
                timeSpent: Date.now() - startTime,
                payload: options,
            });
            return res;
        }
        catch (error) {
            if ((0, common_1.isNeedReconnectError)(error)) {
                this._logger.debug(`Lost connection when publishing message: ${error.message}`);
                this._reconnect();
                // 开启重连后，将当前消息重发，并返回给调用方
                return this.publishMessage(options);
            }
            const msg = `Producer publish message failed: ${error.message}`;
            this._logger.error(msg, {
                payload: (0, error_1.isMQError)(error) ? error.cause : undefined,
            });
            throw new error_1.MQError(`[RocketMQ-node-sdk] ${msg}`);
        }
    }
    async _publishMessageRequest(options) {
        const { topic, body, tag, shardingKey = "", keys, messageProperties } = options;
        const res = await this._client._request({
            method: "POST",
            path: "/v1/messages",
            data: {
                clientToken: this._clientToken,
                message: {
                    topic: this._client.getTopicId(topic),
                    body,
                    tag,
                    shardingKey,
                    keys,
                    properties: (messageProperties === null || messageProperties === void 0 ? void 0 : messageProperties.properties) || {},
                },
            },
            httpAgent: this._producerAgent,
        });
        return res.result;
    }
}
exports.Producer = Producer;
//# sourceMappingURL=Producer.js.map