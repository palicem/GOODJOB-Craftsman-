"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultService = exports.ImagexService = void 0;
const fs_1 = __importStar(require("fs"));
const axios_1 = __importDefault(require("axios"));
const util_1 = require("util");
const lodash_get_1 = __importDefault(require("lodash.get"));
const dayjs_1 = __importDefault(require("dayjs"));
const utils_1 = require("../../base/utils");
const sign_1 = __importStar(require("../../base/sign"));
const client_1 = __importDefault(require("./client"));
const p_limit_1 = __importDefault(require("p-limit"));
const crc_1 = require("crc");
const fsStat = fs_1.promises ? fs_1.promises.stat : (0, util_1.promisify)(fs_1.default.stat);
const fsOpen = (0, util_1.promisify)(fs_1.default.open);
const fsRead = (0, util_1.promisify)(fs_1.default.read);
const fsClose = (0, util_1.promisify)(fs_1.default.close);
const fsAccess = (0, util_1.promisify)(fs_1.default.access);
const BizName = "ImageX";
const DateFormat = "YYYY-MM-DD HH:mm:ss.SSS";
const MIN_CHUNK_SIZE = 1024 * 1024 * 20;
const LARGE_FILE_SIZE = 1024 * 1024 * 1024;
// 进程级chunk上传并发数限制
const maxLimit = (0, p_limit_1.default)(20);
const defaultUploadAuthParams = {
    serviceIds: [],
    storeKeys: [],
    expire: 60 * 60 * 1000,
};
const newAllowStatement = (actions, resources) => {
    return {
        Effect: "Allow",
        Action: actions,
        Resource: resources,
    };
};
// 考虑到filename可能包含中文 因此url encode下 否则分片上传会失败
function getEncodedUri(originUri) {
    if (!originUri)
        return "";
    const arr = originUri.split("/");
    return arr.map((v) => encodeURIComponent(v)).join("/");
}
function formatApiErrMsg(params) {
    var _a, _b, _c;
    return `${BizName} API ${params.Action} error, reqId: ${params.RequestId}, CodeN: ${((_a = params.Error) === null || _a === void 0 ? void 0 : _a.CodeN) || "-"}, Code: ${((_b = params.Error) === null || _b === void 0 ? void 0 : _b.Code) || "-"}, ErrMessage: ${(_c = params.Error) === null || _c === void 0 ? void 0 : _c.Message}`;
}
const formatUploadErrMsg = (res) => {
    return `uri ${res.uri} upload error, ${Object.entries(res.putErr || {})
        .map(([k, v]) => `${k}: ${v || "-"}`)
        .join(", ")}`;
};
const handleErrorResponse = (error, action) => {
    var _a;
    // 2xx but error
    if ((_a = error.message) === null || _a === void 0 ? void 0 : _a.includes("ImageX API")) {
        throw new Error(error.message);
    }
    let errorMessage;
    if (error.response) {
        // not 2xx
        const isJsonType = typeof error.response.data === "object";
        const errStatus = (0, lodash_get_1.default)(error, "response.status", "-");
        const errStatusText = (0, lodash_get_1.default)(error, "response.statusText", "-");
        errorMessage = `${action} response error. errStatus: ${errStatus}, errMsg: ${errStatusText}, ${isJsonType ? JSON.stringify(error.response.data) : error.response.data}, reqId: ${(0, lodash_get_1.default)(error, "response.headers.x-tt-logid", "-")}`;
    }
    else if (error.request) {
        // request but no response
        errorMessage = `The ${action} request was made but no response was received. errCode: ${error.code}, errMsg:  ${error.message}`;
    }
    else {
        errorMessage = `Error happened in setting up the ${action} request. errCode: ${error.code}, errMsg: ${error.message}`;
    }
    throw new Error(errorMessage);
};
class Logger {
    constructor(config) {
        this.print = (params) => {
            const { identifier, endTime, extra } = params || {};
            const msgList = [
                `[${BizName}:${this.name}] unique_id:${identifier} ${endTime ? "end" : "start"}`,
                (0, dayjs_1.default)(endTime !== null && endTime !== void 0 ? endTime : this.startTime).format(DateFormat),
            ];
            if (endTime) {
                msgList.push(`duration: ${endTime - this.startTime}ms`);
            }
            if (extra) {
                msgList.push(extra);
            }
            console.log(msgList.join(", ")); // eslint-disable-line
        };
        this.name = config.name;
        this.startTime = (0, dayjs_1.default)().valueOf(); // ms
    }
}
class ImagexService extends client_1.default {
    constructor(options) {
        super(Object.assign(Object.assign({ host: "imagex.volcengineapi.com" }, options), { defaultVersion: "2018-08-01", serviceName: "imagex" }));
        this.UploadImages = async (params, files, enableChunkUpload) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
            // 1. apply
            if (!files.length || files.length > 10) {
                throw Error(`files num ${files.length} is invalid, the range is [1, 10]`);
            }
            if ((((_a = params.ContentTypes) === null || _a === void 0 ? void 0 : _a.length) || 0) > files.length) {
                throw Error(`ContentTypes num ${((_b = params.ContentTypes) === null || _b === void 0 ? void 0 : _b.length) || 0} is invalid and cannot be greater than files num`);
            }
            if ((((_c = params.StorageClasses) === null || _c === void 0 ? void 0 : _c.length) || 0) > files.length) {
                throw Error(`StorageClasses num ${((_d = params.StorageClasses) === null || _d === void 0 ? void 0 : _d.length) || 0} is invalid and cannot be greater than files num`);
            }
            const applyFinalParams = Object.assign(Object.assign({}, params.ApplyParams), { UploadNum: files.length });
            delete applyFinalParams.requestOptions;
            let originalApplyStoreKeys = [];
            const applyStoreKeys = params.ApplyParams.StoreKeys;
            if (Array.isArray(applyStoreKeys)) {
                if (applyStoreKeys.length !== files.length) {
                    throw Error(`StoreKeys len ${applyStoreKeys.length} != files num ${files.length}`);
                }
                // applyStoreKeys.length > 0
                originalApplyStoreKeys = applyStoreKeys === null || applyStoreKeys === void 0 ? void 0 : applyStoreKeys.slice(0);
                applyFinalParams.StoreKeys = applyStoreKeys.slice(0).sort(); // top 参数鉴权需要将数组按字母序排列
            }
            let logIdentifier = "";
            if (params.ShowDuration) {
                logIdentifier = `${(originalApplyStoreKeys === null || originalApplyStoreKeys === void 0 ? void 0 : originalApplyStoreKeys.length)
                    ? originalApplyStoreKeys === null || originalApplyStoreKeys === void 0 ? void 0 : originalApplyStoreKeys.join(", ")
                    : Math.floor(Math.random() * 1000000)}`;
            }
            let applyLogger;
            if (params.ShowDuration) {
                applyLogger = new Logger({ name: "ApplyImageUpload" });
                applyLogger.print({ identifier: logIdentifier });
            }
            let applyRes;
            try {
                applyRes = await this.ApplyImageUpload(applyFinalParams, Object.assign({ Action: "ApplyImageUpload" }, (((_e = params.ApplyParams) === null || _e === void 0 ? void 0 : _e.requestOptions) || {})));
                if ((_f = applyRes.ResponseMetadata) === null || _f === void 0 ? void 0 : _f.Error) {
                    throw new Error(formatApiErrMsg(applyRes.ResponseMetadata));
                }
            }
            catch (error) {
                handleErrorResponse(error, "ApplyImageUpload");
            }
            finally {
                if (params.ShowDuration && applyLogger) {
                    applyLogger.print({ endTime: (0, dayjs_1.default)().valueOf(), identifier: logIdentifier });
                }
            }
            const reqId = (_g = applyRes.Result) === null || _g === void 0 ? void 0 : _g.RequestId;
            const uploadAddr = (_h = applyRes.Result) === null || _h === void 0 ? void 0 : _h.UploadAddress;
            const uploadHosts = (_j = uploadAddr === null || uploadAddr === void 0 ? void 0 : uploadAddr.UploadHosts) !== null && _j !== void 0 ? _j : [];
            const storeInfos = (_k = uploadAddr === null || uploadAddr === void 0 ? void 0 : uploadAddr.StoreInfos) !== null && _k !== void 0 ? _k : [];
            if (!uploadAddr) {
                throw Error(`no upload address found, reqId: ${reqId}`);
            }
            if (!uploadHosts.length) {
                throw Error(`no upload host found, reqId: ${reqId}`);
            }
            if (storeInfos.length !== files.length) {
                throw Error(`store info len ${storeInfos.length} != upload num ${files.length}, reqId: ${reqId}`);
            }
            // 用户自定义了存储 key
            // Prefix 与 FileExtension 仅当未指定StoreKeys时生效, 因此无需考虑这两个参数
            const newStoreInfos = [];
            if (originalApplyStoreKeys.length) {
                for (const originalStoreKey of originalApplyStoreKeys) {
                    // StoreUri 形如 {bucketid}/xxxx/yyy/zzz 其中 xxxx/yyy/zzz === 用户指定的 StoreKey
                    // 指定StoreKeys时 Prefix 与 FileExtension无影响 无需考虑 此时用户指定的路径即是服务下发的路径
                    const targetStoreInfo = storeInfos.find(({ StoreUri }) => StoreUri.slice(StoreUri.split("/")[0].length + 1) === originalStoreKey);
                    targetStoreInfo && newStoreInfos.push(targetStoreInfo);
                }
            }
            let putLogger;
            if (params.ShowDuration) {
                putLogger = new Logger({ name: "DoUpload" });
                putLogger.print({ identifier: logIdentifier });
            }
            // 2. upload
            // 记录上传任务的执行结果
            const uploadTaskResults = await this.DoUpload(files, uploadHosts[0], newStoreInfos.length ? newStoreInfos : storeInfos, params.ContentTypes, params.StorageClasses, enableChunkUpload);
            if (params.ShowDuration && putLogger) {
                putLogger.print({ endTime: (0, dayjs_1.default)().valueOf(), identifier: logIdentifier });
            }
            // 没有一个文件上传成功 则抛错
            if (!uploadTaskResults.filter((item) => item.success).length) {
                throw Error(`All files have failed to upload.\n${uploadTaskResults.map(formatUploadErrMsg).join("\n")}`);
            }
            // 跳过 commit 阶段, uploadTaskResults 包含成功和失败两种结果
            // 此时模拟CommitImageUpload接口的返回
            if (params.SkipCommit) {
                const results = uploadTaskResults.map((item) => {
                    if (item.success) {
                        return {
                            Uri: item.uri,
                            UriStatus: 2000, //上传成功
                        };
                    }
                    return {
                        Uri: item.uri,
                        UriStatus: 2001,
                        PutError: item.putErr,
                    };
                });
                const openapiLikeResults = {
                    ResponseMetadata: {
                        RequestId: "skip commit",
                        Service: "imagex",
                    },
                    Result: {
                        RequestId: "skip commit",
                        Results: results,
                    },
                    Results: results, // 额外返回这个字段兼容旧返回值
                };
                return openapiLikeResults;
            }
            let commitLogger;
            if (params.ShowDuration) {
                commitLogger = new Logger({ name: "CommitImageUpload" });
                commitLogger.print({ identifier: logIdentifier });
            }
            // 3. commit
            const commitParams = Object.assign({ ServiceId: params.ApplyParams.ServiceId, SessionKey: uploadAddr.SessionKey, SuccessOids: uploadTaskResults.filter((item) => item.success).map((item) => item.uri) }, params.CommitParams);
            delete commitParams.requestOptions;
            let commitRes;
            try {
                commitRes = await this.CommitImageUpload(commitParams, Object.assign({ Action: "CommitImageUpload" }, (((_l = params.CommitParams) === null || _l === void 0 ? void 0 : _l.requestOptions) || {})));
                if ((_m = commitRes.ResponseMetadata) === null || _m === void 0 ? void 0 : _m.Error) {
                    throw new Error(formatApiErrMsg(commitRes.ResponseMetadata));
                }
            }
            catch (error) {
                handleErrorResponse(error, "CommitImageUpload");
            }
            finally {
                if (params.ShowDuration && commitLogger) {
                    commitLogger.print({ endTime: (0, dayjs_1.default)().valueOf(), identifier: logIdentifier });
                }
            }
            // 补充上传失败文件的失败原因
            (_p = (_o = commitRes.Result) === null || _o === void 0 ? void 0 : _o.Results) === null || _p === void 0 ? void 0 : _p.forEach((commitItem) => {
                if (commitItem.UriStatus === 2001) {
                    const uploadErr = uploadTaskResults.find((item) => item.uri === commitItem.Uri);
                    commitItem.PutError = uploadErr === null || uploadErr === void 0 ? void 0 : uploadErr.putErr;
                }
            });
            return commitRes;
        };
        this.DoUpload = async (files, uploadHost, storeInfos, fileContentTypes, fileStorageClasses, chunkUpload) => {
            const promiseArray = [];
            for (let i = 0; i < files.length; i++) {
                const { StoreUri: oid, Auth: auth } = storeInfos[i];
                const file = files[i];
                let size = 0;
                // 根据不同类型获取文件大小
                if (typeof file === "string") {
                    const stat = await fsStat(file);
                    size = stat.size;
                }
                else if (file instanceof ArrayBuffer || ArrayBuffer.isView(file)) {
                    size = file.byteLength; // 直接获取二进制数据大小
                }
                // ReadableStream获取不到size，此处为false，默认直传
                const enableChunkUpload = chunkUpload && size > MIN_CHUNK_SIZE;
                if (enableChunkUpload) {
                    promiseArray.push(this.chunkUpload({
                        uploadHost,
                        oid,
                        auth,
                        file: file,
                        size,
                        isLargeFile: size > LARGE_FILE_SIZE,
                        contentType: fileContentTypes === null || fileContentTypes === void 0 ? void 0 : fileContentTypes[i],
                        storageClass: fileStorageClasses === null || fileStorageClasses === void 0 ? void 0 : fileStorageClasses[i],
                    }));
                }
                else {
                    promiseArray.push(this.directUpload({
                        uploadHost,
                        oid,
                        auth,
                        file: files[i],
                        contentType: fileContentTypes === null || fileContentTypes === void 0 ? void 0 : fileContentTypes[i],
                        storageClass: fileStorageClasses === null || fileStorageClasses === void 0 ? void 0 : fileStorageClasses[i],
                    }));
                }
            }
            return await Promise.all(promiseArray);
        };
        // 大文件分片上传
        this.chunkUpload = async (params) => {
            const { uploadHost: host, oid, auth, file, size, isLargeFile, contentType, storageClass, maxConcurrency = 4, } = params;
            const limit = (0, p_limit_1.default)(maxConcurrency);
            let fd;
            try {
                if (typeof file === "string") {
                    fd = await fsOpen(file, "r");
                }
                const uploadId = await this.initUploadPart(host, oid, auth, isLargeFile, contentType, storageClass);
                // 统一分片计算逻辑
                const n = Math.floor(size / MIN_CHUNK_SIZE);
                const lastSize = size % MIN_CHUNK_SIZE;
                const lastNum = n - 1;
                const parts = [];
                const tasks = [];
                // 分片上传核心逻辑
                for (let i = 0; i < lastNum; i++) {
                    let partNum = i;
                    if (isLargeFile) {
                        // gateway模式下分片序号从1开始
                        partNum = i + 1;
                    }
                    tasks.push(limit(() => this.createUploadTask(host, oid, auth, uploadId, file, fd, // 仅当file为string时有效
                    i * MIN_CHUNK_SIZE, MIN_CHUNK_SIZE, partNum, isLargeFile, contentType, storageClass)).then((checksum) => {
                        parts[i] = checksum;
                    }));
                }
                // 处理最后分片
                tasks.push(limit(() => this.createUploadTask(host, oid, auth, uploadId, file, fd, // 仅当file为string时有效
                lastNum * MIN_CHUNK_SIZE, MIN_CHUNK_SIZE + lastSize, isLargeFile ? lastNum + 1 : lastNum, isLargeFile, contentType, storageClass)).then((checksum) => {
                    parts[lastNum] = checksum;
                }));
                await Promise.all(tasks);
                await this.uploadMergePart(host, oid, auth, uploadId, parts, isLargeFile, contentType, storageClass);
                return { uri: oid, success: true };
            }
            catch (error) {
                const errorItem = {
                    uri: oid,
                    success: false,
                };
                if (error.response) {
                    // 请求成功发出且服务器也响应了状态码，但状态代码超出了 2xx 的范围
                    // 服务器响应分为网关和具体服务
                    const isJsonType = typeof (0, lodash_get_1.default)(error, "response.data") === "object";
                    errorItem.putErr = {
                        errStatus: isJsonType
                            ? (0, lodash_get_1.default)(error, "response.data.error.code", "-")
                            : (0, lodash_get_1.default)(error, "response.status", "-"),
                        errCodeN: (0, lodash_get_1.default)(error, "response.data.error.error_code", "-"),
                        errMsg: isJsonType
                            ? (0, lodash_get_1.default)(error, "response.data.error.message", "-")
                            : (0, lodash_get_1.default)(error, "response.statusText", "-"),
                        errCode: (0, lodash_get_1.default)(error, "response.data.error.error", "-"),
                        reqId: (0, lodash_get_1.default)(error, "response.headers.x-tt-logid", "-"),
                    };
                }
                else if (error.request) {
                    // console.log(error.request);
                    errorItem.putErr = {
                        errMsg: `The put request was made but no response was received: ${error.message}`,
                        errCode: error.code,
                    };
                }
                else {
                    // console.log("Error", error.message);
                    errorItem.putErr = {
                        errMsg: `Error happened in setting up the put request: ${error.message}`,
                        errCode: error.code,
                    };
                }
                return errorItem;
            }
            finally {
                if (fd !== undefined) {
                    await fsClose(fd);
                }
            }
        };
        this.initUploadPart = async (host, oid, auth, isLargeFile, contentType, storageClass) => {
            const url = `https://${host}/${getEncodedUri(oid)}?uploads`;
            const headers = { Authorization: auth };
            if (isLargeFile) {
                headers["X-Storage-Mode"] = "gateway";
            }
            if (contentType) {
                headers["Specified-Content-Type"] = contentType;
            }
            if (storageClass) {
                headers["X-Veimagex-Storage-Class"] = storageClass;
            }
            const res = await (0, axios_1.default)(url, {
                method: "put",
                headers,
            });
            const uploadID = (0, lodash_get_1.default)(res, "data.payload.uploadID", "");
            if (uploadID.length === 0) {
                throw new Error("get empty uploadID");
            }
            return uploadID;
        };
        this.uploadPart = async (host, oid, auth, uploadID, partNumber, data, isLargeFile, contentType, storageClass) => {
            const url = `https://${host}/${getEncodedUri(oid)}?partNumber=${partNumber}&uploadID=${uploadID}`;
            const checkSum = (0, crc_1.crc32)(data).toString(16).padStart(8, "0");
            const headers = { "Content-CRC32": checkSum, Authorization: auth };
            if (isLargeFile) {
                headers["X-Storage-Mode"] = "gateway";
            }
            if (contentType) {
                headers["Specified-Content-Type"] = contentType;
            }
            if (storageClass) {
                headers["X-Veimagex-Storage-Class"] = storageClass;
            }
            await (0, axios_1.default)(url, {
                method: "put",
                headers,
                data,
                maxBodyLength: MIN_CHUNK_SIZE * 2,
            });
            return checkSum;
        };
        this.uploadMergePart = async (host, oid, auth, uploadID, checkSumList, isLargeFile, contentType, storageClass) => {
            const url = `https://${host}/${getEncodedUri(oid)}?uploadID=${uploadID}`;
            const data = this.generateMergeBody(checkSumList);
            const headers = { Authorization: auth };
            if (isLargeFile) {
                headers["X-Storage-Mode"] = "gateway";
            }
            if (contentType) {
                headers["Specified-Content-Type"] = contentType;
            }
            if (storageClass) {
                headers["X-Veimagex-Storage-Class"] = storageClass;
            }
            await (0, axios_1.default)(url, {
                method: "put",
                headers,
                data,
                maxBodyLength: MIN_CHUNK_SIZE * 3,
            });
        };
        this.generateMergeBody = (checkSumList) => {
            if (checkSumList.length === 0) {
                throw new Error("crc32 list empty");
            }
            const s = [];
            for (let i = 0; i < checkSumList.length; i++) {
                s.push(`${i}:${checkSumList[i]}`);
            }
            return s.join(",");
        };
        this.directUpload = async (params) => {
            const { uploadHost, oid, auth, file, contentType, storageClass } = params;
            let fileCopy = file;
            if (Object.prototype.toString.call(fileCopy) === "[object String]") {
                try {
                    await fsAccess(fileCopy);
                    fileCopy = fs_1.default.createReadStream(fileCopy);
                }
                catch (err) {
                    return {
                        uri: oid,
                        success: false,
                        putErr: {
                            errMsg: err.message,
                        },
                    };
                }
            }
            const headers = {
                "Content-CRC32": "Ignore",
                Authorization: auth,
            };
            if (contentType) {
                headers["Specified-Content-Type"] = contentType;
            }
            if (storageClass) {
                headers["X-Veimagex-Storage-Class"] = storageClass;
            }
            try {
                await (0, axios_1.default)(`https://${uploadHost}/${getEncodedUri(oid)}`, {
                    method: "post",
                    headers,
                    data: fileCopy,
                    maxContentLength: Infinity,
                    maxBodyLength: Infinity,
                });
                return { uri: oid, success: true };
            }
            catch (error) {
                const errorItem = {
                    uri: oid,
                    success: false,
                };
                if (error.response) {
                    // 请求成功发出且服务器也响应了状态码，但状态代码超出了 2xx 的范围
                    // 服务器响应分为网关和具体服务
                    const isJsonType = typeof (0, lodash_get_1.default)(error, "response.data") === "object";
                    errorItem.putErr = {
                        errStatus: isJsonType
                            ? (0, lodash_get_1.default)(error, "response.data.error.code", "-")
                            : (0, lodash_get_1.default)(error, "response.status", "-"),
                        errCodeN: (0, lodash_get_1.default)(error, "response.data.error.error_code", "-"),
                        errMsg: isJsonType
                            ? (0, lodash_get_1.default)(error, "response.data.error.message", "-")
                            : (0, lodash_get_1.default)(error, "response.statusText", "-"),
                        errCode: (0, lodash_get_1.default)(error, "response.data.error.error", "-"),
                        reqId: (0, lodash_get_1.default)(error, "response.headers.x-tt-logid", "-"),
                    };
                }
                else if (error.request) {
                    // console.log(error.request);
                    errorItem.putErr = {
                        errMsg: `The put request was made but no response was received: ${error.message}`,
                        errCode: error.code,
                    };
                }
                else {
                    // console.log("Error", error.message);
                    errorItem.putErr = {
                        errMsg: `Error happened in setting up the put request: ${error.message}`,
                        errCode: error.code,
                    };
                }
                return errorItem;
            }
        };
        /**
         * 获取上传临时密钥, 默认超时时间为 1h
         */
        this.GetUploadAuth = (options) => {
            const { serviceIds, storeKeys, uploadOverwrite, uploadPolicy, expire } = options !== null && options !== void 0 ? options : defaultUploadAuthParams;
            const serviceIdPolicy = (serviceIds === null || serviceIds === void 0 ? void 0 : serviceIds.length)
                ? serviceIds.map((serviceId) => `trn:ImageX:*:*:ServiceId/${serviceId}`)
                : ["trn:ImageX:*:*:ServiceId/*"];
            const storeKeysPolicy = (storeKeys === null || storeKeys === void 0 ? void 0 : storeKeys.length)
                ? storeKeys.map((storeKey) => `trn:ImageX:*:*:StoreKeys/${storeKey}`)
                : ["trn:ImageX:*:*:StoreKeys/*"];
            const policy = {
                Statement: [
                    newAllowStatement(["ImageX:ApplyImageUpload", "ImageX:CommitImageUpload"], [...serviceIdPolicy, ...storeKeysPolicy]),
                ],
            };
            // 配置重名覆盖上传
            if (typeof uploadOverwrite === "boolean") {
                policy.Statement.push(newAllowStatement(["UploadOverwrite"], [`${uploadOverwrite}`]));
            }
            // 配置上传策略
            if (uploadPolicy && typeof uploadPolicy === "object" && Object.keys(uploadPolicy).length) {
                policy.Statement.push(newAllowStatement(["UploadPolicy"], [JSON.stringify(uploadPolicy)]));
            }
            return this.signSts2(policy, expire !== null && expire !== void 0 ? expire : 60 * 60 * 1000);
        };
        /**
         * 获取临时上传凭证
         */
        this.GetUploadAuthToken = (query) => {
            const applyUploadToken = this._signUrl({
                method: "GET",
                params: Object.assign({ Action: "ApplyImageUpload", Version: "2018-08-01" }, query),
            });
            const commitUploadToken = this._signUrl({
                method: "POST",
                params: Object.assign({ Action: "CommitImageUpload", Version: "2018-08-01" }, query),
            });
            const tokens = {
                Version: "v1",
                ApplyUploadToken: applyUploadToken,
                CommitUploadToken: commitUploadToken,
            };
            const tokensJson = JSON.stringify(tokens).replace("\\u0026", "&");
            return Buffer.from(tokensJson).toString("base64");
        };
        this._signUrl = (options) => {
            const { region } = (0, utils_1.getDefaultOption)();
            const sessionToken = this.getSessionToken();
            const accessKeyId = this.getAccessKeyId();
            const secretKey = this.getSecretKey();
            if (!accessKeyId || !secretKey) {
                throw new Error("accessKeyId or secretKey is invalid");
            }
            const { params, method = "GET", serviceName = "ImageX" } = options;
            // 使用临时的一个signer来转换utc时间，因为实际上使用signer需要传入params字段
            const date = new sign_1.default({ method: "", region: "" }, "ImageX")
                .iso8601(new Date())
                .replace(/[:\-]|\.\d{3}/g, "");
            const credentialScope = [date.substr(0, 8), region, serviceName, "request"].join("/");
            const signedHeaders = "";
            const paramsMap = Object.assign({ "X-Date": date, "X-NotSignBody": "", "X-Credential": accessKeyId + "/" + credentialScope, "X-Algorithm": "HMAC-SHA256", "X-SignedHeaders": signedHeaders, "X-SignedQueries": "" }, params);
            const sortedQueryMap = Object.keys(paramsMap)
                .sort()
                .reduce((map, curKey) => {
                map[curKey] = paramsMap[curKey];
                return map;
            }, {});
            if (sessionToken) {
                paramsMap["X-Security-Token"] = sessionToken;
            }
            paramsMap["X-SignedQueries"] = Object.keys(sortedQueryMap).join(";");
            const signer = new sign_1.default({
                region,
                method,
                pathname: "/",
                params: paramsMap,
            }, "ImageX");
            const signature = signer.signature({ accessKeyId, secretKey }, date);
            paramsMap["X-Signature"] = signature.toString();
            return (0, sign_1.queryParamsToString)(paramsMap);
        };
    }
    async createUploadTask(host, oid, auth, uploadId, file, fd, offset, chunkSize, partNum, isLargeFile, contentType, storageClass) {
        return maxLimit(async () => {
            let buffer;
            if (typeof file === "string") {
                // 此处无需关闭 fd，上传完成后统一处理
                const buf = Buffer.alloc(chunkSize);
                await fsRead(fd, buf, 0, chunkSize, offset);
                buffer = buf;
            }
            else {
                // 二进制数据直接切片
                const sourceBuffer = Buffer.from(file instanceof ArrayBuffer ? file : file.buffer);
                buffer = sourceBuffer.subarray(offset, offset + chunkSize);
            }
            return this.uploadPart(host, oid, auth, uploadId, partNum, buffer, isLargeFile, contentType, storageClass);
        });
    }
}
exports.ImagexService = ImagexService;
exports.defaultService = new ImagexService();
//# sourceMappingURL=index.js.map