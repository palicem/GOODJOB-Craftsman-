"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Consumer = void 0;
const Worker_1 = require("./Worker");
const common_1 = require("./utils/common");
const error_1 = require("./utils/error");
const common_2 = require("./utils/common");
class Consumer extends Worker_1.Worker {
    constructor(client, options) {
        if (!client)
            throw new error_1.MQError("Please pass the client instance of consumer");
        if (!options)
            throw new error_1.MQError("Please pass the options of consumer");
        const fields = (0, common_1.requiredCheck)(options, ["group"]);
        if (fields.length > 0) {
            throw new error_1.MQError(`[RocketMQ-node-sdk] ${fields.join(", ")} is necessary`);
        }
        const { group, maxMessageNumber = 10, maxWaitTimeMs = 3000, pollingInterval = 0 } = options;
        super(client, { type: "consumer" });
        this._group = group;
        this._subscriptions = {};
        this._maxMessageNumber = maxMessageNumber;
        this._maxWaitTimeMs = maxWaitTimeMs;
        this._pollingInterval = pollingInterval;
        this._consumerAgent = this._workerAgent;
        this._running = false;
    }
    get groupId() {
        return this._client.getGroupId(this._group);
    }
    get subscriptions() {
        const subs = {};
        const topicNames = Object.keys(this._subscriptions);
        topicNames.forEach((topicName) => {
            const topicId = this._client.getTopicId(topicName);
            subs[topicId] = this._subscriptions[topicName];
        });
        return subs;
    }
    subscribe(options) {
        if (!options) {
            throw new error_1.MQError(`[RocketMQ-node-sdk] please the subscribe option`);
        }
        const { topic, tag = "" } = options;
        if (!topic) {
            throw new error_1.MQError(`[RocketMQ-node-sdk] topic is necessary`);
        }
        this._subscriptions[topic] = tag;
    }
    connect() {
        const topicsCount = Object.keys(this._subscriptions).length;
        if (topicsCount === 0) {
            throw new error_1.MQError(`[RocketMQ-node-sdk] consumer connect failed: no topic subscribed`);
        }
        return this._connect({
            group: this.groupId,
            subscriptions: this.subscriptions,
            properties: {},
        });
    }
    close() {
        return this._close();
    }
    async run(options) {
        if (!options) {
            throw new error_1.MQError("[RocketMQ-node-sdk] please pass the runner option");
        }
        if (!options.eachMessage) {
            throw new error_1.MQError("[RocketMQ-node-sdk] eachMessage is necessary");
        }
        if (this._workerStatus !== "connected") {
            throw new error_1.MQError(`[RocketMQ-node-sdk] Can not run consumer when consumer's status is ${this._workerStatus}`);
        }
        if (this._running) {
            throw new error_1.MQError("[RocketMQ-node-sdk] Consumer is already running");
        }
        this._running = true;
        while (this._running) {
            if (this._pollingInterval) {
                await (0, common_1.sleep)(this._pollingInterval);
            }
            try {
                const startTime = Date.now();
                const messages = await this._consume(options);
                this._logger.debug("Consume messages succeed.", {
                    timeSpent: Date.now() - startTime,
                    payload: { messagesCount: messages === null || messages === void 0 ? void 0 : messages.length },
                });
            }
            catch (error) {
                if ((0, common_2.isNeedReconnectError)(error)) {
                    this._logger.debug(`Lost connection when consuming message: ${error.message}`);
                    this._reconnect(); // 开始重新连接
                    await this._waitReconnectIfNecessary(); // 等待重连成功后才进入下一次轮询
                    continue;
                }
                this._logger.error(`Consume messages failed: ${error.message}`, {
                    payload: (0, error_1.isMQError)(error) ? error.cause : undefined,
                });
            }
        }
    }
    async stop() {
        this._running = false;
    }
    async _consume(options) {
        const { eachMessage } = options;
        const res = await this._pullMessageRequest();
        const messages = res.messages || [];
        if (messages.length > 0) {
            // consume message
            const runResult = await Promise.all(messages.map(async (msg) => {
                try {
                    const msgResult = await eachMessage(msg);
                    return { handle: msg.msgHandle, succeed: msgResult };
                }
                catch (error) {
                    // ack filed when  error
                    return { handle: msg.msgHandle, succeed: false };
                }
            }));
            // ack message
            await this._ackMessagesRequest({
                acks: runResult.filter((item) => item.succeed).map((item) => item.handle),
                nacks: runResult.filter((item) => !item.succeed).map((item) => item.handle),
            });
        }
        return messages;
    }
    async _pullMessageRequest() {
        const res = await this._client._request({
            method: "POST",
            path: `/v1/group/${encodeURIComponent(this.groupId)}/messages`,
            data: {
                clientToken: this._clientToken,
                maxMessageNumber: this._maxMessageNumber,
                maxWaitTimeMs: this._maxWaitTimeMs,
            },
            httpAgent: this._consumerAgent,
        });
        return res.result;
    }
    async _ackMessagesRequest(options) {
        const { acks, nacks = [] } = options;
        const res = await this._client._request({
            method: "DELETE",
            path: `/v1/group/${encodeURIComponent(this.groupId)}/msghandles`,
            data: {
                clientToken: this._clientToken,
                acks,
                nacks,
            },
            httpAgent: this._consumerAgent,
        });
        return res.result;
    }
}
exports.Consumer = Consumer;
//# sourceMappingURL=Consumer.js.map