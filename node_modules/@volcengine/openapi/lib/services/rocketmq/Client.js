"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const uuid_1 = require("uuid");
const sign_1 = __importDefault(require("../../base/sign"));
const request_1 = require("./utils/request");
const Consumer_1 = require("./Consumer");
const Producer_1 = require("./Producer");
const error_1 = require("./utils/error");
const common_1 = require("./utils/common");
const SDK_VERSION = "0.0.2";
// client 对应session超时时间
const SESSION_TIMEOUT = 60;
const SERVICE_NAME = "rocketmq";
class Client {
    constructor(options) {
        if (!options) {
            throw new error_1.MQError("[RocketMQ-node-sdk] Please pass the config of client");
        }
        const fields = (0, common_1.requiredCheck)(options, ["endpoint", "instanceId", "accessKey", "secretKey"]);
        if (fields.length > 0) {
            throw new error_1.MQError(`[RocketMQ-node-sdk] ${fields.join(", ")} is necessary`);
        }
        const { endpoint, accessKey, secretKey, instanceId } = options;
        const endpointInfo = new URL(options.endpoint);
        if (endpointInfo.protocol !== "http:" || !endpointInfo.hostname) {
            throw new error_1.MQError("[RocketMQ-node-sdk] endpoint is not a correct HTTP address");
        }
        this._endpoint = endpoint;
        this._accessKey = accessKey;
        this._secretKey = secretKey;
        this._instanceId = instanceId;
    }
    get VERSION() {
        return SDK_VERSION;
    }
    get SESSION_TIMEOUT() {
        return SESSION_TIMEOUT;
    }
    createProducer() {
        return new Producer_1.Producer(this);
    }
    createConsumer(options) {
        return new Consumer_1.Consumer(this, options);
    }
    async _request(options) {
        const singer = this._sign(options);
        const { headers } = options;
        const url = new URL(options.path, this._endpoint).href;
        const res = await (0, request_1.sendRequest)(Object.assign(Object.assign({}, options), { url, headers: Object.assign(Object.assign({}, headers), singer.request.headers), data: singer.request.body }));
        return res;
    }
    getTopicId(topic) {
        if ((0, common_1.instanceNeedNamespace)(this._instanceId)) {
            return `${this._instanceId}%${topic}`;
        }
        return topic;
    }
    getGroupId(group) {
        if ((0, common_1.instanceNeedNamespace)(this._instanceId)) {
            return `${this._instanceId}%${group}`;
        }
        return group;
    }
    _createRequestId() {
        const requestId = (0, uuid_1.v4)();
        return requestId;
    }
    _sign(options) {
        const { method, path, data } = options;
        const urlInfo = new URL(path, this._endpoint);
        const singer = new sign_1.default({
            region: "all",
            method: method,
            pathname: path,
            headers: { Host: urlInfo.host },
            body: Object.assign(Object.assign({}, data), { requestId: this._createRequestId() }),
        }, SERVICE_NAME);
        singer.addAuthorization({ accessKeyId: this._accessKey, secretKey: this._secretKey });
        return singer;
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map