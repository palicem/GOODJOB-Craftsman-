"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.instanceNeedNamespace = exports.isNeedReconnectError = exports.Resolver = exports.requiredCheck = exports.sleep = void 0;
const error_1 = require("./error");
const errors_1 = require("../protocol/errors");
function sleep(time) {
    return new Promise((rs) => setTimeout(rs, time));
}
exports.sleep = sleep;
function requiredCheck(obj, keys) {
    const fields = [];
    for (const key of keys) {
        if (obj[key] === undefined) {
            fields.push(key);
        }
    }
    return fields;
}
exports.requiredCheck = requiredCheck;
class Resolver {
    constructor() {
        this.promise = new Promise((rs, rj) => {
            this.resolve = rs;
            this.reject = rj;
        });
    }
}
exports.Resolver = Resolver;
function isNeedReconnectError(err) {
    var _a;
    if ((0, error_1.isMQError)(err) && err.type === "REQUEST_ERROR") {
        const cause = err.cause;
        // 两种情况需要重连
        // 1. 没有状态码， 说明有网络问题
        // 2. 有状态码，但是code是ClientNotFound 说明token已经失效
        return !(cause === null || cause === void 0 ? void 0 : cause.status) || ((_a = cause === null || cause === void 0 ? void 0 : cause.response) === null || _a === void 0 ? void 0 : _a.code) === errors_1.ErrorCode.ClientNotFound;
    }
    else {
        return false;
    }
}
exports.isNeedReconnectError = isNeedReconnectError;
function instanceNeedNamespace(instanceId) {
    return /^MQ_INST/.test(instanceId);
}
exports.instanceNeedNamespace = instanceNeedNamespace;
//# sourceMappingURL=common.js.map